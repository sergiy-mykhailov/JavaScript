# **JavaScript - Base Level**
***

# 1. Data types

## 7 встроенных типов:
  null, undefined, boolean, number, string, object и symbol(ES6)

```
typeof 0              // number
typeof true           // boolean
typeof 'Hello'        // string
typeof Math           // object
typeof null           // object (ошибка в языке, сохраняется для совместимости, null – это отдельный тип данных)
typeof Symbol('Hi')   // symbol (New ES6)
typeof function(){}   // "function" (object Но typeof выделяет функции отдельно, возвращая для них "function")
```

# 2. Operators 

## 2.1 Arithmetic

### Арифметические операции: + * / - %

Приоритет | Название 	  |Обозначение
:--------:|:-----------:|:---------:
15 	      |унарный плюс |	+
15 	      |унарный минус| -
14 	      |умножение    |	*
14 	      |деление 	    | /
13 	      |сложение     | +
13 	      |вычитание    | -
3 	      |присваивание | =


## 2.2. Assignment

```
var a, b, c;

a = b = c = 2 + 2;

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```

### Оператор "=" возвращает значение
```
var a = 1;
var b = 2;

var c = 3 - (a = b + 1);

alert( a ); // 3
alert( c ); // 0
```

### Инкремент (более короткая запись для i = i + 1):
```
var i = 0;
alert( i++ );      // 0, Постфиксная форма, возвращает старое значение
alert( ++i );      // 2, Префиксная форма, возвращает новое значение
```

### Декремент (более короткая запись для i = i - 1):
```
var i = 10;
alert( i-- );      // 10, Постфиксная форма, возвращает старое значение
alert( --i );      // 8, Префиксная форма, возвращает новое значение
```

### Совмещённые операторы
```
var n = 2;
n += 5;     // теперь n=7 (работает как n = n + 5)
n *= 2;     // теперь n=14 (работает как n = n * 2)
```
Так можно сделать для операторов +,-,*,/,% и бинарных <<,>>,>>>,&,|,^

## 2.3. Comparison

Значения разных типов приводятся к числу при сравнении, за исключением строгого равенства === (!==).

### Операторы сравнения
> < == !=  >= <= === !== >== <== !

### Сравнение разных типов
```
alert( '2' > 1 );     // true, сравнивается как 2 > 1
alert( '01' == 1 );   // true, сравнивается как 1 == 1
alert( false == 0 );  // true, false становится числом 0
alert( true == 1 );   // true, так как true становится числом 1.
2 == '2'              // True
2 === '2'             // False
undefined == null     // True
undefined === null    // False
false == ""    // true
false == []    // true
false == {}    // false
"" == 0        // true
"" == []       // true
"" == {}       // false
0 == []        // true
0 == {}        // false
0 == null      // false
```
[Чит-лист](http://dorey.github.io/JavaScript-Equality-Table/)

### Сравнение с null и undefined
1. Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё
2. При преобразовании в число null становится 0, а undefined становится NaN.

```
alert( null > 0 );        // false
alert( null == 0 );       // false
alert(null >= 0);         // true
alert( undefined > 0 );   // false
alert( undefined < 0 );   // false
alert( undefined == 0 );  // false
```

## 2.4. Type Operators

### Численное преобразование
```
var a = +"123";         // 123
var a = Number("123");  // 123
```
Значение     | Преобразуется в...
-------------|-------------------
undefined	   | NaN
null         | 0
true / false | 1 / 0
''           | 0
'25'         | 25
'abc'        | NaN

### Логическое преобразование
```
alert( !!"0" ); // true
alert( !!" " ); // любые непустые строки, даже из пробелов - true!
```
Значение        | Преобразуется в...
----------------|-------------------
undefined, null	| false
Числа	          | Все true, кроме 0, NaN -- false.
Строки	        | Все true, кроме пустой строки "" -- false
Объекты	        | Всегда true

```
alert( null >= 0 );       // true, т.к. null преобразуется к 0
alert( null > 0 );        // false (не больше), т.к. null преобразуется к 0
alert( null == 0 );       // false (и не равен!), т.к. == рассматривает null особо.
alert( undefined > 0 );   // false, т.к. undefined -> NaN
alert( undefined == 0 );  // false, т.к. это undefined (без преобразования)
alert( undefined < 0 );   // false, т.к. undefined -> NaN
```

### Логические операторы
Если значение не логического типа – то оно к нему приводится в целях вычислений. 
#### || (ИЛИ)
  *  если хотя бы один из аргументов true, то возвращает true, иначе – false
  *  вычисляет операнды слева направо до первого «истинного»
  *  возвращает то значение, на котором остановились вычисления
  *  если все значения «ложные», то возвращает последнее
#### && (И)
  *  возвращает true, если оба аргумента истинны, а иначе – false
  *  вычисляет операнды слева направо до первого «ложного»
  *  возвращает первое «ложное»
  *  если все значения истинные – то возвращает последнее значение
#### ! (НЕ)
  *  Сначала приводит аргумент к логическому типу true/false.
  *  Затем возвращает противоположное значение.


## 2.5. Bitwise
Значение        | Оператор
----------------|-------------------
AND(и)          | & 
OR(или)         | (вертикальная черта) 
XOR(побитовое исключающее или) | ^ 
NOT(не) | ~ 
LEFT SHIFT(левый сдвиг) | << 
RIGHT SHIFT(правый сдвиг) | >> 
ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) | >>> 

# 3. Main statements 

## 3.1. If

### Оператор If:
```
if (...) {
  ...
} else if (...) {
  ...
} else {
  ...
}
```

### Тернарный оператор '?':
```
переменная = условие ? значениеУсловиеВерно : значениеУсловиеНеверно
```

### В логическом контексте:
  *  Число **0**, пустая строка **""**, **null** и **undefined**, а также **NaN** являются **false**,
  *  Остальные значения – **true**.


## 3.2. switch
```
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}
```
Если break нет, то выполнение пойдёт ниже по следующим case, при этом остальные проверки игнорируются.

## 3.3. loops
### Цикл while
Пока условие верно – выполняется код из тела цикла:
```
while (условие) {
  // код, тело цикла
}
```
### Цикл do..while
Цикл сначала выполняет тело, а затем проверяет условие:
```
do {
  // тело цикла
} while (условие);
```
### Цикл for
```
for (начало; условие; шаг) {
  // ... тело цикла ...
  [break] // Прерывание цикла
  [continue] // прекращает выполнение текущей итерации цикла
}
```
### Цикл for..in
Порядок перебора соответствует порядку объявления для нечисловых ключей, а числовые – сортируются (в современных браузерах).
```
for (key in obj) {
  /* ... делать что-то с obj[key] ... */
}
```
### break/continue
```
outer: for (var i = 0; i < 3; i++) {
  for (var j = 0; j < 3; j++) {
    break; // // прекращает выполнение текущего цикла
    break outer; // прекращает выполнение цикла с меткой "outer"
    continue; // прекращает выполнение текущей итерации внутр.цикла
  }
}
```

## 3.4. try catch
```
try {
   .. пробуем выполнить код ..
} catch(e) {
   .. перехватываем исключение ..
} finally {
   .. выполняем всегда ..
}
```
Блок finally срабатывает при любом выходе из try..catch, в том числе и return.

#### Объект ошибки
  *  name - Тип ошибки. Например: "ReferenceError".
  *  message - текстовое сообщение о деталях ошибки.
  *  stack - содержит строку с информацией о последовательности вызовов, которая привела к ошибке. 

# 4. Hoisting

__Hoisting__ представляет процесс доступа к переменным до их определения.

Компиляция кода происходит в два прохода:
1. компилятор получает все объявления переменных, все идентификаторы.
2. выполнение кода

Следующий код вызовет ошибку ReferenceError: aa is not defined:
```
console.log(aa);
```

Следующий код выведет значение "undefined":
```
console.log(foo);   // undefined
var foo = "Tom";
```

Переменные a и b используются до опеределения. По умолчанию им присваиваются значения undefined. А если умножить undefined на undefined, то получим NaN:
```
var c = a * b;
var a = 7;
var b = 3;
console.log(c); // NaN
```

Все то же самое относится и к использованию функций:
```
display();
 
function display(){
    console.log("Hello Hoisting");
}
```

Когда функция определяется в виде переменной, получим ошибку TypeError: display is not a function:
```
display();
 
var display = function (){
    console.log("Hello Hoisting");
}
```

# 5. Numbers 
## 5.1. Converting

#### parseInt(string[, radix])
**parseInt()** принимает строку в качестве аргумента и возвращает целое число в соответствии с указанным основанием системы счисления.
* `string` - строка.
* `radix` - основание системы счисления. (Целое число между 2 и 36. По умолчанию: 10)

```JavaScript
parseInt("015", 10);            // 15
parseInt(" 0xF", 16);           // 15
parseInt("1111", 2);            // 15
parseInt("15px", 10);           // 15
parseInt("15e2", 10);           // 15
parseInt("Hello", 8);           // NaN
parseInt(-15.1, 10);            // -15
parseInt(0.00000000000434, 10); // 4
```

#### parseFloat(string)
**parseFloat()** принимает строку в качестве аргумента и возвращает десятичное число (число с плавающей точкой)
* `string` - строка.
```javascript
parseFloat("3.14");   // 3.14
parseFloat("314e-2"); // 3.14
parseFloat("2.5km");  // 2.5 
parseFloat("FF2");    // NaN
```

#### isNaN(value)
**isNaN()** определяет является ли литерал или переменная нечисловым значением (NaN) или нет.
* `value` - литерал или переменная.

```js
isNaN(NaN);       // true
isNaN(undefined); // true
isNaN({});        // true
isNaN(true);      // false
isNaN(null);      // false
isNaN(37);        // false
isNaN("37.37");   // false: "37.37" преобразуется в число 37.37 которое не NaN
isNaN("");        // false: пустая строка преобразуется в 0 которое не NaN
isNaN("37,5");    // true
isNaN(new Date());                // false
isNaN(new Date().toString());     // true
// Пример почему использование isNaN не всегда уместно:
isNaN("blabla")   // true: "blabla" преобразованно в число. 
```
**P.S.** Более надёжный метод для проверки: `Number.isNaN()`

#### isFinite(testValue)
**isFinite()** определяет, является ли переданное значение конечным числом.
* `testValue` - литерал или переменная.

```js
isFinite(Infinity);   // false
isFinite(NaN);        // false
isFinite(-Infinity);  // false
isFinite(0);          // true
isFinite(2e64);       // true
isFinite("0");        // true
Number.isFinite("0"); // false
```
**P.S.** Более надёжный метод для проверки: `Number.isFinite()`

## 5.2. Properties

* **Number.EPSILON** - Наименьший интервал между двумя представимыми числами.
* **Number.MAX_SAFE_INTEGER** - Максимальное целое число, которое можно безопасно использовать в JavaScript (253 - 1).
* **Number.MAX_VALUE** - Наибольшее представимое положительное число.
* **Number.MIN_SAFE_INTEGER** - Минимальное целое число, которое можно безопасно использовать в (-(253 - 1)).
* **Number.MIN_VALUE** - Наименьшее представимое положительное число — то есть, самое близкое к нулю положительное число (которое ещё не является нулём).
* **Number.NaN** - Специальное значение для представления «не числа».
* **Number.NEGATIVE_INFINITY** - Специальное значение для представления отрицательной бесконечности; возвращается при переполнении.
* **Number.POSITIVE_INFINITY** - Специальное значение для представления положительной бесконечности; возвращается при переполнении.
* **Number.prototype** - Позволяет добавлять свойства к объекту Number. 

## 5.3. Methods
* **Number.isNaN(value)** - Определяет, является ли переданнное значение значением NaN.
* **Number.isFinite(value)** - Определяет, является ли переданное значение конечным числом.
* **Number.isInteger(value)** - Определяет, является ли тип переданного значения «числом», а само число — целым значением.
* **Number.isSafeInteger(value)** - Определяет, является ли переданное значение безопасным целым числом (числом в диапазоне от -(253 - 1) до 253 - 1).
* **Number.parseFloat(string)** - Представляет собой тот же самый метод, что и метод parseFloat глобального объекта.
* **Number.parseInt(string[, radix])** - Представляет собой тот же самый метод, что и метод parseInt глобального объекта.
* **Number.prototype.toExponential([digits])** - Возвращает строку, представляющую число в экспоненциальной записи.
  * `digits` - Количество цифр после десятичной запятой.
* **Number.prototype.toFixed([digits])** - Возвращает строку, представляющую число в записи с фиксированной запятой.
  * `digits` - Количество цифр после десятичной запятой.
* **Number.prototype.toLocaleString([locales[, options]])** - Возвращает строку с языко-зависимым представлением числа.
  * `locales` - Строка с языковой меткой BCP 47, либо массив таких строк.
  * `options` - Объект с некоторыми или всеми из следующих свойств:
    * `localeMatcher` - Используемый алгоритм сопоставления локалей. Возможные значения "lookup", "best fit"; (Default: "best fit")
    * `style` - Используемый стиль форматирования. Возможные значения: "decimal", "currency", "percent" (Default: "decimal")
    * `currency` - Валюта, используемая при форматировании валют. Возможные значения: коды валют ISO 4217.
    * `currencyDisplay` - Отображение валюты. Возможные значения: "symbol", "code", "name" (Default: "symbol")
    * `useGrouping` - Определяет, использовать ли разделители групп разрядов (Default: true)
    * `minimumIntegerDigits` - Минимальное используемое количество цифр целой части числа. от 1 до 21 (Default: 1)
    * `minimumFractionDigits` - Минимальное используемое количество цифр дробной части числа. от 0 до 20  (Default: 0)
    * `maximumFractionDigits` - Максимальное используемое количество цифр дробной части числа. от 0 до 20 (Default: minimumFractionDigits)
    * `minimumSignificantDigits` - Минимальное используемое количество значащих цифр числа. от 1 до 21 (Default: 1)
    * `maximumSignificantDigits` - Максимальное используемое количество значащих цифр числа. от 1 до 21 (Default: minimumSignificantDigits)
* **Number.prototype.toPrecision([precision])** - Возвращает строку, представляющую число с указанной точностью в экспоненциальной записи, либо записи с фиксированной запятой.
  * `precision` - Количество значащих цифр.
* **Number.prototype.toSource()** - Возвращает объектный литерал, представляющий объект Number; вы можете использовать это значение для создания нового объекта.
* **Number.prototype.toString([radix])** - Возвращает строку, представляющую указанный объект по указанному основанию системы счисления.
  * `radix` - основание системы счисления.
* **Number.prototype.valueOf()** - Возвращает примитивное значение указанного объекта.

# 6. Strings
## 6.1 Properties
## 6.2 Methods

# 7. Dates
## 7.1 Properties
## 7.2 Methods
## 7.3 Formats
## 7.4 Timezones

# 8. Arrays
## 8.1 Properties
## 8.2 Methods
## 8.3 Sorting

# 9. Functions
## 9.1 Closures
## 9.2 declaration
## 9.3 arguments array
## 9.4 invocation

# 10. Type conversion

# 11. Prototypes, Inharitance
## 11.1. Prototypes
## 11.2. Inharitance

# 12. Math Object

# 13. Scopes

# 14. Objects

# 15. Timeouts, Intervals
## 15.1. Timeouts
## 15.2. Intervals





