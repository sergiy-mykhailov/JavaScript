# **JavaScript - Base Level**
***

# 1. Data types

## 7 встроенных типов:
  null, undefined, boolean, number, string, object и symbol(ES6)

```
typeof 0              // number
typeof true           // boolean
typeof 'Hello'        // string
typeof Math           // object
typeof null           // object (ошибка в языке, сохраняется для совместимости, null – это отдельный тип данных)
typeof Symbol('Hi')   // symbol (New ES6)
typeof function(){}   // "function" (object Но typeof выделяет функции отдельно, возвращая для них "function")
```

# 2. Operators 

## 2.1 Arithmetic

### Арифметические операции: + * / - %

Приоритет | Название 	  |Обозначение
:--------:|:-----------:|:---------:
15 	      |унарный плюс |	+
15 	      |унарный минус| -
14 	      |умножение    |	*
14 	      |деление 	    | /
13 	      |сложение     | +
13 	      |вычитание    | -
3 	      |присваивание | =


## 2.2. Assignment

```
var a, b, c;

a = b = c = 2 + 2;

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```

### Оператор "=" возвращает значение
```
var a = 1;
var b = 2;

var c = 3 - (a = b + 1);

alert( a ); // 3
alert( c ); // 0
```

### Инкремент (более короткая запись для i = i + 1):
```
var i = 0;
alert( i++ );      // 0, Постфиксная форма, возвращает старое значение
alert( ++i );      // 2, Префиксная форма, возвращает новое значение
```

### Декремент (более короткая запись для i = i - 1):
```
var i = 10;
alert( i-- );      // 10, Постфиксная форма, возвращает старое значение
alert( --i );      // 8, Префиксная форма, возвращает новое значение
```

### Совмещённые операторы
```
var n = 2;
n += 5;     // теперь n=7 (работает как n = n + 5)
n *= 2;     // теперь n=14 (работает как n = n * 2)
```
Так можно сделать для операторов +,-,*,/,% и бинарных <<,>>,>>>,&,|,^

## 2.3. Comparison

Значения разных типов приводятся к числу при сравнении, за исключением строгого равенства === (!==).

### Операторы сравнения
> < == !=  >= <= === !== >== <== !

### Сравнение разных типов
```
alert( '2' > 1 );     // true, сравнивается как 2 > 1
alert( '01' == 1 );   // true, сравнивается как 1 == 1
alert( false == 0 );  // true, false становится числом 0
alert( true == 1 );   // true, так как true становится числом 1.
2 == '2'              // True
2 === '2'             // False
undefined == null     // True
undefined === null    // False
false == ""    // true
false == []    // true
false == {}    // false
"" == 0        // true
"" == []       // true
"" == {}       // false
0 == []        // true
0 == {}        // false
0 == null      // false
```
[Чит-лист](http://dorey.github.io/JavaScript-Equality-Table/)

### Сравнение с null и undefined
1. Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё
2. При преобразовании в число null становится 0, а undefined становится NaN.

```
alert( null > 0 );        // false
alert( null == 0 );       // false
alert(null >= 0);         // true
alert( undefined > 0 );   // false
alert( undefined < 0 );   // false
alert( undefined == 0 );  // false
```

## 2.4. Type Operators

### Численное преобразование
```
var a = +"123";         // 123
var a = Number("123");  // 123
```
Значение     | Преобразуется в...
-------------|-------------------
undefined	   | NaN
null         | 0
true / false | 1 / 0
''           | 0
'25'         | 25
'abc'        | NaN

### Логическое преобразование
```
alert( !!"0" ); // true
alert( !!" " ); // любые непустые строки, даже из пробелов - true!
```
Значение        | Преобразуется в...
----------------|-------------------
undefined, null	| false
Числа	          | Все true, кроме 0, NaN -- false.
Строки	        | Все true, кроме пустой строки "" -- false
Объекты	        | Всегда true

```
alert( null >= 0 );       // true, т.к. null преобразуется к 0
alert( null > 0 );        // false (не больше), т.к. null преобразуется к 0
alert( null == 0 );       // false (и не равен!), т.к. == рассматривает null особо.
alert( undefined > 0 );   // false, т.к. undefined -> NaN
alert( undefined == 0 );  // false, т.к. это undefined (без преобразования)
alert( undefined < 0 );   // false, т.к. undefined -> NaN
```

### Логические операторы
Если значение не логического типа – то оно к нему приводится в целях вычислений. 
#### || (ИЛИ)
  *  если хотя бы один из аргументов true, то возвращает true, иначе – false
  *  вычисляет операнды слева направо до первого «истинного»
  *  возвращает то значение, на котором остановились вычисления
  *  если все значения «ложные», то возвращает последнее
#### && (И)
  *  возвращает true, если оба аргумента истинны, а иначе – false
  *  вычисляет операнды слева направо до первого «ложного»
  *  возвращает первое «ложное»
  *  если все значения истинные – то возвращает последнее значение
#### ! (НЕ)
  *  Сначала приводит аргумент к логическому типу true/false.
  *  Затем возвращает противоположное значение.


## 2.5. Bitwise
Значение        | Оператор
----------------|-------------------
AND(и)          | & 
OR(или)         | (вертикальная черта) 
XOR(побитовое исключающее или) | ^ 
NOT(не) | ~ 
LEFT SHIFT(левый сдвиг) | << 
RIGHT SHIFT(правый сдвиг) | >> 
ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) | >>> 

# 3. Main statements 

## 3.1. If

### Оператор If:
```
if (...) {
  ...
} else if (...) {
  ...
} else {
  ...
}
```

### Тернарный оператор '?':
```
переменная = условие ? значениеУсловиеВерно : значениеУсловиеНеверно
```

### В логическом контексте:
  *  Число **0**, пустая строка **""**, **null** и **undefined**, а также **NaN** являются **false**,
  *  Остальные значения – **true**.


## 3.2. switch
```
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}
```
Если break нет, то выполнение пойдёт ниже по следующим case, при этом остальные проверки игнорируются.

## 3.3. loops
### Цикл while
Пока условие верно – выполняется код из тела цикла:
```
while (условие) {
  // код, тело цикла
}
```
### Цикл do..while
Цикл сначала выполняет тело, а затем проверяет условие:
```
do {
  // тело цикла
} while (условие);
```
### Цикл for
```
for (начало; условие; шаг) {
  // ... тело цикла ...
  [break] // Прерывание цикла
  [continue] // прекращает выполнение текущей итерации цикла
}
```
### Цикл for..in
Порядок перебора соответствует порядку объявления для нечисловых ключей, а числовые – сортируются (в современных браузерах).
```
for (key in obj) {
  /* ... делать что-то с obj[key] ... */
}
```
### break/continue
```
outer: for (var i = 0; i < 3; i++) {
  for (var j = 0; j < 3; j++) {
    break; // // прекращает выполнение текущего цикла
    break outer; // прекращает выполнение цикла с меткой "outer"
    continue; // прекращает выполнение текущей итерации внутр.цикла
  }
}
```

## 3.4. try catch
```
try {
   .. пробуем выполнить код ..
} catch(e) {
   .. перехватываем исключение ..
} finally {
   .. выполняем всегда ..
}
```
Блок finally срабатывает при любом выходе из try..catch, в том числе и return.

#### Объект ошибки
  *  name - Тип ошибки. Например: "ReferenceError".
  *  message - текстовое сообщение о деталях ошибки.
  *  stack - содержит строку с информацией о последовательности вызовов, которая привела к ошибке. 

# 4. Hoisting

__Hoisting__ представляет процесс доступа к переменным до их определения.

Компиляция кода происходит в два прохода:
1. компилятор получает все объявления переменных, все идентификаторы.
2. выполнение кода

Следующий код вызовет ошибку ReferenceError: aa is not defined:
```
console.log(aa);
```

Следующий код выведет значение "undefined":
```
console.log(foo);   // undefined
var foo = "Tom";
```

Переменные a и b используются до опеределения. По умолчанию им присваиваются значения undefined. А если умножить undefined на undefined, то получим NaN:
```
var c = a * b;
var a = 7;
var b = 3;
console.log(c); // NaN
```

Все то же самое относится и к использованию функций:
```
display();
 
function display(){
    console.log("Hello Hoisting");
}
```

Когда функция определяется в виде переменной, получим ошибку TypeError: display is not a function:
```
display();
 
var display = function (){
    console.log("Hello Hoisting");
}
```






